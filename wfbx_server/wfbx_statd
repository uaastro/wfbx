#!/usr/bin/env python3

import json
import socket
import struct
import selectors
import time
import click
import atexit
import signal
import sys


def parse_host_port(s: str):
    host, port = s.rsplit(":", 1)
    return host, int(port)


def make_ingest_socket(bind_addr: str):
    host, port = parse_host_port(bind_addr)
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    if hasattr(socket, 'SO_REUSEPORT'):
        try:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        except OSError:
            pass
    s.bind((host, port))
    s.setblocking(False)
    return s


def make_mcast_sender(mcast_addr: str, loopback_only: bool = True):
    m_ip, m_port = parse_host_port(mcast_addr)
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    # TTL 0: never leaves the host; keep LOOP enabled so local subscribers receive it
    s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 0)
    s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_LOOP, 1)
    if loopback_only:
        s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_IF, socket.inet_aton('127.0.0.1'))
    return s, (m_ip, m_port)


def safe_loads(b: bytes):
    try:
        return json.loads(b.decode('utf-8', 'replace'))
    except Exception:
        return None


@click.command()
@click.option('--ingest', default='0.0.0.0:9100', show_default=True, help='UDP bind for ingest (host:port)')
@click.option('--mcast', default='239.255.0.1:9100', show_default=True, help='Multicast fanout address (ip:port)')
@click.option('--host_id', default='core', show_default=True, help='Host ID to inject if missing')
@click.option('--max_len', default=8192, show_default=True, help='Max accepted datagram length (bytes)')
def main(ingest, mcast, host_id, max_len):
    
    rx = None
    tx = None
    
    def cleanup():
        for s in (rx, tx):
            try:
                if s is not None:
                    s.close()
            except Exception as e:
                print(e)
                
    def signal_handler(sig, frame):
        cleanup()
        sys.exit(0)
        
    atexit.register(cleanup)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    rx = make_ingest_socket(ingest)
    tx, tx_addr = make_mcast_sender(mcast, loopback_only=True)
    sel = selectors.DefaultSelector()
    sel.register(rx, selectors.EVENT_READ)

    schema_default = 'wfbx.stat/1'

    while True:
        events = sel.select(timeout=1.0)
        if not events:
            continue
        for key, _ in events:
            if key.fileobj is rx:
                try:
                    data, _ = rx.recvfrom(65535)
                except BlockingIOError:
                    continue
                if not data:
                    continue
                if len(data) > max_len:
                    # drop oversized
                    continue
                obj = safe_loads(data)
                if not isinstance(obj, dict):
                    continue
                # inject schema/host_id if missing
                if 'schema' not in obj:
                    obj['schema'] = schema_default
                if 'host_id' not in obj or not obj.get('host_id'):
                    obj['host_id'] = host_id
                # ensure ts present
                if 'ts' not in obj:
                    obj['ts'] = time.time()
                out = json.dumps(obj, separators=(',', ':')).encode('utf-8')
                try:
                    tx.sendto(out, tx_addr)
                except OSError:
                    pass


if __name__ == '__main__':
    main()

