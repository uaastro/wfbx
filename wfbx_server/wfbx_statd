#!/usr/bin/env python3

import atexit
import selectors
import signal
import socket
import struct
import sys
from typing import Optional, Tuple

import click

from wfbxlib.stats import core as stats_core


def parse_host_port(addr: str) -> Tuple[str, int]:
    host, port = addr.rsplit(":", 1)
    return host, int(port)


def make_ingest_socket(bind_addr: str) -> socket.socket:
    host, port = parse_host_port(bind_addr)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    if hasattr(socket, "SO_REUSEPORT"):
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        except OSError:
            pass
    sock.bind((host, port))
    sock.setblocking(False)
    return sock


def make_mcast_sender(mcast_addr: str, loopback_only: bool = True) -> Tuple[socket.socket, Tuple[str, int]]:
    host, port = parse_host_port(mcast_addr)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 0)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_LOOP, 1)
    if loopback_only:
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_IF, socket.inet_aton("127.0.0.1"))
    return sock, (host, port)


def log_block(*messages: str) -> None:
    print("#--- STATD LOG ---")
    for msg in messages:
        print(msg)
    print("#--- /STATD LOG ---")
    sys.stdout.flush()


HOST_ID_OFFSET = 4 + 1 + 1 + 24  # magic + version + module_type + module_id
HOST_ID_LEN = 16
HEADER_SIZE = stats_core.HEADER_STRUCT.size
CRC_OFFSET = HEADER_SIZE - 4


def ensure_host_id(packet: bytes, desired_host_id: str) -> bytes:
    if len(packet) < HEADER_SIZE:
        return packet

    host_bytes = packet[HOST_ID_OFFSET : HOST_ID_OFFSET + HOST_ID_LEN]
    if host_bytes.rstrip(b"\0"):
        return packet

    patched = bytearray(packet)
    encoded = desired_host_id.encode("ascii", "ignore")[:HOST_ID_LEN]
    encoded = encoded.ljust(HOST_ID_LEN, b"\0")
    patched[HOST_ID_OFFSET : HOST_ID_OFFSET + HOST_ID_LEN] = encoded

    crc32 = struct.unpack_from(">I", packet, CRC_OFFSET)[0]
    if crc32 != 0:
        header = bytearray(patched[:HEADER_SIZE])
        header[CRC_OFFSET:CRC_OFFSET + 4] = b"\0\0\0\0"
        checksum = stats_core.compute_crc32(bytes(header) + patched[HEADER_SIZE:])
        struct.pack_into(">I", patched, CRC_OFFSET, checksum)

    return bytes(patched)


@click.command()
@click.option("--ingest", default="0.0.0.0:9601", show_default=True, help="UDP bind for ingest (host:port)")
@click.option("--mcast", default="239.255.0.1:9100", show_default=True, help="Multicast fanout address (ip:port)")
@click.option("--host_id", default="core", show_default=True, help="Host ID fallback when packet omits it")
@click.option("--max_len", default=1450, show_default=True, help="Max accepted datagram length (bytes)")
def main(ingest: str, mcast: str, host_id: str, max_len: int) -> None:
    rx: Optional[socket.socket] = None
    tx: Optional[socket.socket] = None

    def cleanup() -> None:
        for sock in (rx, tx):
            if sock is not None:
                try:
                    sock.close()
                except Exception:
                    pass

    def handle_signal(_sig, _frame) -> None:
        cleanup()
        sys.exit(0)

    atexit.register(cleanup)
    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    rx = make_ingest_socket(ingest)
    log_block(f"[STATD] ingest socket bound to {ingest}")
    tx, tx_addr = make_mcast_sender(mcast, loopback_only=True)
    log_block(f"[STATD] multicast sender ready -> {tx_addr[0]}:{tx_addr[1]}")

    selector = selectors.DefaultSelector()
    selector.register(rx, selectors.EVENT_READ)

    while True:
        events = selector.select(timeout=0.1)
        if not events:
            continue
        for key, _mask in events:
            if key.fileobj is not rx:
                continue
            while True:
                try:
                    datagram, _peer = rx.recvfrom(65535)
                except BlockingIOError:
                    break
                except OSError:
                    log_block("[STATD] recvfrom encountered OSError; skipping")
                    break

                if not datagram:
                    continue
                if len(datagram) > max_len:
                    log_block(f"[STATD] dropped packet len={len(datagram)} > max_len={max_len}")
                    continue

                log_block(f"[STATD] received packet len={len(datagram)}")
                out_packet = ensure_host_id(datagram, host_id)
                if out_packet is not datagram:
                    log_block("[STATD] host_id was injected into packet")

                try:
                    tx.sendto(out_packet, tx_addr)
                    log_block(f"[STATD] forwarded packet len={len(out_packet)} -> {tx_addr[0]}:{tx_addr[1]}")
                except OSError as exc:
                    log_block(f"[STATD] sendto error: {exc}")
                    pass



if __name__ == "__main__":
    main()
