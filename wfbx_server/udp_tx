#!/usr/bin/python3

import socket
import time
import struct
import atexit
import signal
import sys

import click


@click.command()
@click.option('--ip', default="127.0.0.1", help='ip to send packets')
@click.option('--port', default=5600, help='udp port')
@click.option('--pksize', default=1024, help='packet size')
@click.option('--pks', default=800, help='bitrate in pkt/s')
def main(ip, port, pksize, pks):
    
    sock = None
    
    def cleanup():
        try:
            if sock is not None:
                sock.close()
        except Exception as e:
            print(e)
                
    def signal_handler(sig, frame):
        cleanup()
        sys.exit(0)
        
    atexit.register(cleanup)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    #------------------------------------------------------------------
    UDP_IP = ip
    UDP_PORT = port
    PACKET_SIZE = int(pksize)
    BITRATE = float(pks)  # packets/sec

    if PACKET_SIZE < 1:
        raise click.BadParameter('packet size must be >= 1 byte', param_hint='--pksize')
    if BITRATE <= 0:
        raise click.BadParameter('bitrate must be > 0 pkt/s', param_hint='--pks')

    BASE_DELAY = 1.0 / BITRATE
    #------------------------------------------------------------------
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

    if PACKET_SIZE >= 12:
        header_size = 12

        def build_header(sequence: int, timestamp: float) -> bytes:
            return struct.pack("!Id", sequence & 0xFFFFFFFF, timestamp)

        sequence_mask = 0xFFFFFFFF
    elif PACKET_SIZE >= 4:
        header_size = 4

        def build_header(sequence: int, _timestamp: float) -> bytes:
            return struct.pack("!I", sequence & 0xFFFFFFFF)

        sequence_mask = 0xFFFFFFFF
    else:
        header_size = 1

        def build_header(sequence: int, _timestamp: float) -> bytes:
            return struct.pack("!B", sequence & 0xFF)

        sequence_mask = 0xFF

    padding = b"\xFF" * max(0, PACKET_SIZE - header_size)
    next_send = time.monotonic()
    sequence = -1

    while True:
        now = time.monotonic()
        if now < next_send:
            time.sleep(next_send - now)
            now = time.monotonic()

        sequence = (sequence + 1) & sequence_mask
        send_timestamp = now
        header = build_header(sequence, send_timestamp)
        payload_len = PACKET_SIZE - header_size
        if payload_len > 0:
            packet = header + padding[:payload_len]
        else:
            packet = header

        sock.sendto(packet, (UDP_IP, UDP_PORT))

        next_send += BASE_DELAY
        if now - next_send > BASE_DELAY:
            next_send = now + BASE_DELAY
            
if __name__ == '__main__':
    main()
