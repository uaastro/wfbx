#!/usr/bin/python3
import click
import os
import time
import socket
import sys
import signal
import tempfile
import logging
from commentedconfigparser import CommentedConfigParser
from multiprocessing import Process
import multiprocessing


logging.basicConfig(
    level=logging.INFO,
    format="[CH_SWITCHER] %(asctime)s %(levelname)s %(message)s",
)


def _write_config_atomic(config, path):
    directory = os.path.dirname(path) or "."
    tmp_path = None
    try:
        with tempfile.NamedTemporaryFile(mode="w", dir=directory, delete=False) as tmp:
            config.write(tmp)
            tmp.flush()
            os.fsync(tmp.fileno())
            tmp_path = tmp.name
        os.replace(tmp_path, path)
    except Exception:
        if tmp_path:
            try:
                os.unlink(tmp_path)
            except OSError:
                pass
        logging.exception("Failed to update config %s", path)
        raise

def rx(exit_flag, wfb_cfg, sock, ch_id, mpkts, cmd_prfx, wlan_sections):
        
    config = CommentedConfigParser()
    config.read(wfb_cfg)
        
    while exit_flag.value == 0:
        data, addr = sock.recvfrom(mpkts)
        line = data.decode("utf-8")
        parts = line.split(':')
        if len(parts) < 2:
            logging.warning("Malformed message from %s: %s", addr, line)
            continue
        try:
            channels = {section: config[section]['channel'] for section in wlan_sections}
        except KeyError:
            logging.exception("Missing channel configuration for sections %s in %s", wlan_sections, wfb_cfg)
            continue
        if parts[0] == str(ch_id):
            desired = parts[1]
            if desired == 'def':
                continue
            current_values = set(channels.values())
            if len(current_values) == 1 and desired == next(iter(current_values)):
                continue
            for section in wlan_sections:
                config[section]['channel'] = desired
            logging.info("Updating %s channel -> %s", ",".join(wlan_sections), desired)
            try:
                _write_config_atomic(config, wfb_cfg)
                exit_flag.value = 1
            except Exception:
                logging.error("Failed to persist channel change, keeping previous value")
            continue
                #sys.exit(0)

def tx(exit_flag, wfb_cfg, sock, ip_server, port_server, ch_id, hb_freq, cmd_prfx, wlan_sections):
    config = CommentedConfigParser()
    config.read(wfb_cfg)
    channel = 'def'
    try:
        channels = {section: config[section]['channel'] for section in wlan_sections}
    except KeyError:
        logging.exception("Missing channel configuration for sections %s in %s", wlan_sections, wfb_cfg)
        channels = {}
    if channels:
        channel = next(iter(channels.values()))
        if len(set(channels.values())) > 1:
            logging.warning("Sections %s have divergent channel values %s; using %s for heartbeat",
                            ",".join(wlan_sections), channels, channel)
    msg = cmd_prfx + ':' + str(ch_id) + ':' + str(channel)
    sock.sendto(msg.encode("utf-8"),(ip_server,port_server))
    while exit_flag.value == 0:
        sock.sendto(msg.encode("utf-8"),(ip_server, port_server))
        time.sleep(1/hb_freq)

@click.command()
@click.option('--wfb_cfg', default='wfbx_server.cfg', help='target cfg file, default wfbx_server.cfg')
@click.option('--ip', default="127.0.0.1", help='switcher ip adress def: 127.0.0.1')
@click.option('--port', default=14420, help='switcher port def: 14420')
@click.option('--ip_server', default="127.0.0.1", help='channel switcher server def 127.0.0.1')
@click.option('--port_server', default=14410, help='channel switcher server def 14410')
@click.option('--ch_id', default=100, help='channel_id def 100')
@click.option('--hb_freq', default=1, help='heartbeat frequency in Hz (def: 1)')
@click.option('--mpkts', default=2048, help='max udp packet size def 2048')
@click.option('--cmd_prfx', default='chsw', help='command prefix def chsw')
@click.option('--wlan', default='wlan', help='wlan section(s) to change (comma-separated) def wlan')

def main(wfb_cfg,ip,port,ip_server,port_server,ch_id,hb_freq,mpkts,cmd_prfx,wlan):

    wfb_server_dir = os.path.dirname(os.path.abspath(__file__))+"/"
    wfb_cfg = wfb_server_dir+wfb_cfg

    wlan_sections = [section.strip() for section in wlan.split(',') if section.strip()]
    if not wlan_sections:
        logging.error("No valid wlan sections provided via --wlan")
        sys.exit(1)
    # preserve order but ensure uniqueness
    seen = set()
    ordered_sections = []
    for section in wlan_sections:
        if section not in seen:
            seen.add(section)
            ordered_sections.append(section)
    wlan_sections = ordered_sections

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR,1)
    sock.bind((ip, port))

    manager = multiprocessing.Manager()
    exit_flag = manager.Value('i',0)

    thread_rx = Process(target=rx, args=(exit_flag,wfb_cfg,sock,ch_id,mpkts,cmd_prfx,wlan_sections))
    thread_rx.start()

    thread_tx = Process(target=tx, args=(exit_flag,wfb_cfg,sock,ip_server,port_server,ch_id,hb_freq,cmd_prfx,wlan_sections))
    thread_tx.start()

    def signal_handler(sig, frame):
        exit_flag.value = 1
        thread_tx.terminate()
        thread_tx.join(timeout=0.01)
        if thread_tx.is_alive():
            thread_tx.kill()
            thread_tx.join()
        
        thread_rx.terminate()
        thread_rx.join(timeout=0.01)
        if thread_rx.is_alive():
            thread_rx.kill()
            thread_rx.join()
        
        sock.close()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    logging.info(
        "ch_switcher start cfg=%s bind=%s:%s server=%s:%s ch_id=%s hb_freq=%s wlan_sections=%s",
        wfb_cfg, ip, port, ip_server, port_server, ch_id, hb_freq, ",".join(wlan_sections)
    )

    thread_rx.join()
    thread_tx.join()

if __name__ == '__main__':
    main()
