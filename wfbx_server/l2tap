#!/usr/bin/python3

import atexit
import os
import secrets
import selectors
import signal
import socket
import sys
import time
from typing import Optional, Tuple

import click

from wfbxlib import stats_core, tap as taplib


def parse_ifaces(value: str) -> Tuple[str, ...]:
    if not value:
        return ()
    parts = []
    for token in value.replace(",", " ").split():
        token = token.strip()
        if token:
            parts.append(token)
    return tuple(parts)


@click.command()
@click.option('--tap', 'tap_name', default='wfbxtap0', help='TAP interface name / default: wfbxtap0')
@click.option('--ip_rx', default='0.0.0.0', help='local IP to receive UDP / default: 0.0.0.0')
@click.option('--port_rx', default=5750, type=int, help='local UDP port to receive / default: 5750')
@click.option('--ip_tx', default='127.0.0.1', help='remote IP to send UDP / default: 127.0.0.1')
@click.option('--port_tx', default=5750, type=int, help='remote UDP port / default: 5750')
@click.option('--mtu', default=1500, type=int, help='TAP MTU (0 = do not change) / default: 1500')
@click.option('--bridge', default='', help='attach TAP to an existing bridge')
@click.option('--bridge-stp', type=click.Choice(['auto', 'on', 'off']), default='auto',
              help='STP mode for the bridge: auto/on/off / default: auto')
@click.option('--stat_ip', default='127.0.0.1', help='statd IP / default: 127.0.0.1')
@click.option('--stat_port', default=9601, type=int, help='statd UDP port / default: 9601')
@click.option('--stat_id', default='l2tap', help='stat module id / default: l2tap')
@click.option('--stat_period', default=1000, type=int, help='stats period in ms (0 = disable) / default: 1000')
def main(
    tap_name: str,
    ip_rx: str,
    port_rx: int,
    ip_tx: str,
    port_tx: int,
    mtu: int,
    bridge: str,
    bridge_stp: str,
    stat_ip: str,
    stat_port: int,
    stat_id: str,
    stat_period: int,
):
    if not sys.platform.startswith("linux"):
        raise click.ClickException("l2tap requires Linux with /dev/net/tun")

    tap_fd: Optional[int] = None
    tap_actual: Optional[str] = None
    sock_rx: Optional[socket.socket] = None
    sock_tx: Optional[socket.socket] = None
    sock_stat: Optional[socket.socket] = None
    stat_addr: Optional[Tuple[str, int]] = None

    def cleanup():
        nonlocal tap_fd, tap_actual, sock_rx, sock_tx, sock_stat
        for sock in (sock_rx, sock_tx, sock_stat):
            if sock is None:
                continue
            try:
                sock.close()
            except Exception:
                pass
        sock_rx = sock_tx = sock_stat = None

        if tap_fd is not None:
            try:
                taplib.set_persist(tap_fd, False)
            except Exception:
                pass
            try:
                os.close(tap_fd)
            except Exception:
                pass
            tap_fd = None

        if tap_actual is not None:
            try:
                if os.path.exists(f"/sys/class/net/{tap_actual}"):
                    taplib.delete_iface(tap_actual)
            except Exception:
                pass
            tap_actual = None

    def signal_handler(sig, frame):
        cleanup()
        sys.exit(0)

    atexit.register(cleanup)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # --- TAP init ---
    tap_sysfs_path = f"/sys/class/net/{tap_name}"
    if os.path.exists(tap_sysfs_path):
        print(f"[l2tap] removing stale TAP {tap_name}")
        try:
            taplib.delete_iface(tap_name)
        except taplib.TapError as exc:
            raise click.ClickException(f"failed to remove stale TAP '{tap_name}': {exc}")

    try:
        tap_fd, tap_actual = taplib.open_tap(
            tap_name,
            persist=False,
            multi_queue=False,
        )
    except taplib.TapError as exc:
        raise click.ClickException(str(exc))

    print(f"[l2tap] TAP: {tap_actual} (fd={tap_fd})")

    tap_mac_bytes = bytearray(secrets.token_bytes(6))
    tap_mac_bytes[0] = (tap_mac_bytes[0] | 0x02) & 0xFE
    tap_mac = ":".join(f"{octet:02x}" for octet in tap_mac_bytes)
    print(f"[l2tap] TAP MAC: {tap_mac}")

    try:
        taplib.configure_iface(
            tap_actual,
            mtu=mtu if mtu > 0 else None,
            txqueuelen=None,
            mac=tap_mac,
            up=True,
        )
    except taplib.TapError as exc:
        cleanup()
        raise click.ClickException(str(exc))

    # --- Bridge handling ---
    bridge_name = bridge or ""
    if bridge_name:
        try:
            if bridge_stp in ("on", "off"):
                taplib.ensure_bridge(
                    bridge_name,
                    stp=(bridge_stp == "on"),
                    up=True,
                )
            else:
                taplib.configure_iface(bridge_name, up=True)
            taplib.add_ifaces_to_bridge(bridge_name, (tap_actual,))
            print(f"[l2tap] TAP joined bridge {bridge_name}")
        except taplib.TapError as exc:
            cleanup()
            raise click.ClickException(str(exc))

    # --- UDP sockets ---
    sock_rx = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        sock_rx.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    except Exception:
        pass
    try:
        sock_rx.bind((ip_rx, port_rx))
    except OSError as exc:
        cleanup()
        raise click.ClickException(f"failed to bind UDP socket on {ip_rx}:{port_rx}: {exc}")

    sock_tx = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        sock_tx.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    except Exception:
        pass
    try:
        sock_tx.connect((ip_tx, port_tx))
    except OSError as exc:
        cleanup()
        raise click.ClickException(f"failed to connect to {ip_tx}:{port_tx}: {exc}")

    print(f"[l2tap] UDP listen: {ip_rx}:{port_rx}")
    print(f"[l2tap] UDP send  : {ip_tx}:{port_tx}")

    if stat_period > 0:
        try:
            socket.inet_aton(stat_ip)
            sock_stat = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            stat_addr = (stat_ip, stat_port)
        except OSError:
            print(f"[l2tap] invalid stat_ip '{stat_ip}', stats disabled")
            sock_stat = None
            stat_addr = None

    selector = selectors.DefaultSelector()
    selector.register(tap_fd, selectors.EVENT_READ, data="tap")
    selector.register(sock_rx, selectors.EVENT_READ, data="udp")

    # --- stats ---
    period_start = time.monotonic()
    stat_tick = 0
    tx_pkts = 0
    rx_pkts = 0
    tx_bytes = 0
    rx_bytes = 0
    tap_write_drops = 0
    udp_send_drops = 0

    read_buf = max(2000, (mtu if mtu > 0 else 2000) + 64)

    def send_stats(now: float):
        nonlocal period_start, stat_tick
        nonlocal tx_pkts, rx_pkts, tx_bytes, rx_bytes, tap_write_drops, udp_send_drops

        if sock_stat is None or stat_addr is None or tap_actual is None:
            return

        dt_ms = max(1, int((now - period_start) * 1000))
        period_ms = dt_ms
        rate_tx_kbps = (tx_bytes * 8) / (period_ms if period_ms > 0 else 1) / 1000.0
        rate_rx_kbps = (rx_bytes * 8) / (period_ms if period_ms > 0 else 1) / 1000.0
        summary = stats_core.Summary(
            dt_ms=dt_ms,
            packets_total=tx_pkts,
            bytes_total=rx_pkts,
            ctrl_epoch_sent=int(rate_tx_kbps * 10),
            iface_count=int(rate_rx_kbps * 10),
            tx_count=tap_write_drops,
            flags=udp_send_drops,
        )
        preview = (
            f"tap={tap_actual} pkts_tx={tx_pkts} pkts_rx={rx_pkts} "
            f"rate_tx={rate_tx_kbps:.1f}kbps rate_rx={rate_rx_kbps:.1f}kbps "
            f"drops_tap={tap_write_drops} drops_udp={udp_send_drops}"
        ).encode("utf-8")
        sections = stats_core.make_sections([
            (int(stats_core.SectionType.SUMMARY), summary.pack()),
            (int(stats_core.SectionType.TEXT_PREVIEW), preview),
        ])
        header = stats_core.Header(
            version=1,
            module_type=stats_core.ModuleType.L2_TAP,
            module_id=stat_id,
            host_id="",
            tick_id=stat_tick,
            timestamp_us=int(time.time() * 1_000_000),
            flags=0,
            section_count=0,
            payload_len=0,
        )
        packet = stats_core.build_packet(header, sections, with_crc=True)
        try:
            sock_stat.sendto(packet, stat_addr)
        except OSError as exc:
            print(f"[l2tap] failed to send stats: {exc}")
        stat_tick += 1
        period_start = now
        tx_pkts = rx_pkts = 0
        tx_bytes = rx_bytes = 0
        tap_write_drops = udp_send_drops = 0

    while True:
        try:
            events = selector.select(timeout=0.5)
        except OSError as exc:
            print(f"[l2tap] select() failed: {exc}")
            break

        now = time.monotonic()
        if stat_period > 0 and (now - period_start) * 1000 >= stat_period:
            send_stats(now)

        if not events:
            continue

        for key, _mask in events:
            if key.data == "tap":
                try:
                    data = os.read(tap_fd, read_buf)
                except OSError as exc:
                    if exc.errno in (11, 35):  # EAGAIN/EWOULDBLOCK
                        continue
                    print(f"[l2tap] TAP read error: {exc}")
                    cleanup()
                    sys.exit(1)
                if not data:
                    continue
                try:
                    sock_tx.send(data)
                except OSError as exc:
                    udp_send_drops += 1
                    print(f"[l2tap] UDP send error: {exc}")
                    continue
                tx_pkts += 1
                tx_bytes += len(data)
            elif key.data == "udp":
                try:
                    data, _addr = sock_rx.recvfrom(read_buf)
                except OSError as exc:
                    if exc.errno in (11, 35):
                        continue
                    print(f"[l2tap] UDP receive error: {exc}")
                    cleanup()
                    sys.exit(1)
                if not data:
                    continue
                try:
                    written = os.write(tap_fd, data)
                    if written != len(data):
                        tap_write_drops += 1
                        print(f"[l2tap] partial TAP write ({written}/{len(data)})")
                        continue
                except OSError as exc:
                    tap_write_drops += 1
                    print(f"[l2tap] TAP write error: {exc}")
                    continue
                rx_pkts += 1
                rx_bytes += len(data)

    cleanup()
    print("[l2tap] stopped")


if __name__ == '__main__':
    main()
