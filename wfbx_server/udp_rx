#!/usr/bin/python3

import socket
import time
import struct

from rich.console import Console
from rich.live import Live
from rich.table import Table
from rich import box
import select
import tty
import termios
import atexit
import signal
import sys
import click

@click.command()
@click.option('--ip', default="0.0.0.0", help='address of udp server/default 0.0.0.0')
@click.option('--port', default=5600, help='port of udp server/default 5600')
@click.option('--mpksize', default=2048, help='max packet size/default 2048')
@click.option('--mode', default=2, help='set mode=1 for accept udp_test packets generated by ud_tx or set mode=2 (default) for any other udp packets format')

def main(ip, port,mpksize,mode):

    sock = None
    
    def cleanup():
        try:
            if sock is not None:
                sock.close()
        except Exception as e:
            print(e)
                
    def signal_handler(sig, frame):
        cleanup()
        sys.exit(0)
        
    atexit.register(cleanup)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    UDP_IP = ip
    UDP_PORT = port
    MAX_PACKET_SIZE = mpksize
    MODE=mode
    

    def status_line(
        sequence,
        pkt,
        pkts,
        interval,
        pksize,
        lost_period,
        lost_total,
        bitrate,
        quality,
        delay_avg,
        delay_min,
        delay_max,
        delay_current,
    ) -> Table:
        table = Table(expand=True, show_header=False, highlight=True, box=box.ASCII2)
        interval_ms = interval * 1000
        bitrate_kbps = bitrate / 1000
        table.add_column("status")
        def fmt_delay(value):
            return "n/a" if value is None else f"{value * 1000:.2f}"
        table.add_row(
            f"seq:{sequence} pkt:{pkt} pkt/s:{pkts} qlt:{quality:.1f}% "
            f"lostΔ:{lost_period} lostΣ:{lost_total} bitrate:{bitrate_kbps:.2f} kbps int:{interval_ms:.2f} ms "
            #f"delay(avg/min/max/cur):{fmt_delay(delay_avg)}/{fmt_delay(delay_min)}/{fmt_delay(delay_max)}/{fmt_delay(delay_current)} ms "
            f"pk_size:{pksize} bytes"
        )
        return table

    def status_line2(pkt, pkts, interval, pk_min, pk_max, apkt_size, bitrate) -> Table:
        table = Table(expand=True, show_header=False, highlight=True, box=box.ASCII2)
        interval_ms = interval * 1000
        bitrate_kbps = bitrate / 1000
        table.add_column("status")
        table.add_row(
            f"[bold]^X[/] E[yellow]x[/]it pkt:{pkt} pkt/s:{pkts} bw:{bitrate_kbps:.2f} kbps ia:{interval_ms:.2f} ms pk_size min:[green]{pk_min}[/] max:[green]{pk_max}[/] avg:[green]{apkt_size:.0f}[/] bytes"
        )
        return table

    def parse_header(data: bytes):
        size = len(data)
        if size == 0:
            raise ValueError("empty packet")
        if size >= 12:
            sequence, timestamp = struct.unpack("!Id", data[:12])
            return sequence, timestamp, 12, 0xFFFFFFFF
        if size >= 4:
            (sequence,) = struct.unpack("!I", data[:4])
            return sequence, None, 4, 0xFFFFFFFF
        (sequence,) = struct.unpack("!B", data[:1])
        return sequence, None, 1, 0xFF

    #------------------------------------------------------------------
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        if hasattr(socket, 'SO_REUSEPORT'):
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
    except Exception:
        pass
    sock.bind((UDP_IP, UDP_PORT))
    
    console = Console()
    console.print("\n")
    console.rule("UDP-RX",style="blue") 
    console.print("")
    if MODE==1:
        console.print(f"udp_ip: {UDP_IP} udp_port: {UDP_PORT} mode: [green]test[/]")
    elif MODE==2:
        console.print(f"udp_ip: {UDP_IP} udp_port: {UDP_PORT} mode: [green]discovery[/]")
    console.print("")
    console.log("UDP-RX started...")
    console.print("")

    i = 0
    i_int = 0
    clock = time.monotonic
    time_pp = clock()
    time_int = time_pp
    time_start = time_pp
    pklost = 0
    pksize_min = MAX_PACKET_SIZE
    pksize_max = 0
    bytes_interval = 0
    lost_interval_base = 0
    old_settings = termios.tcgetattr(sys.stdin)

    try:
        tty.setcbreak(sys.stdin.fileno())  # turn input mode on
        if MODE==1:
            time_start = clock()
            time_pp = time_start
            time_int = time_start
            bytes_interval = 0
            lost_interval_base = 0
            delay_sum_interval = 0.0
            delay_count_interval = 0
            delay_min_interval = None
            delay_max_interval = None
            with Live(
                status_line("-", 0, 0, 0, 0, 0, 0, 0.0, 100.0, None, None, None, None),
                refresh_per_second=4,
            ) as live:
                prev_seq = None
                prev_mask = None
                last_latency = None
                while True:
                    if select.select([sys.stdin], [], [], 0)[0]:  # check input
                        c = sys.stdin.read(1)  # read char
                        if c == '\x18':  # if CTRL-X
                            live.console.log("UDP-RX finished")
                            end_time = clock()
                            duration = end_time - time_start
                            rate = i / duration if duration > 0 else 0
                            live.console.print()
                            live.console.log("pkt: ", i, "\n")
                            live.console.log("avg pkt/s: ", f"{rate:.2f}")
                            break
                    packet, addr = sock.recvfrom(MAX_PACKET_SIZE)
                    packet_size = len(packet)
                    bytes_interval += packet_size
                    receive_time = clock()
                    try:
                        sequence, send_time, _header_len, seq_mask = parse_header(packet)
                        sequence_display = str(sequence)
                    except (struct.error, ValueError):
                        sequence = None
                        send_time = None
                        seq_mask = None
                        sequence_display = "n/a"

                    interval = receive_time - time_pp
                    time_pp = receive_time
                    i += 1

                    if sequence is not None:
                        if prev_seq is None or seq_mask != prev_mask:
                            prev_seq = sequence
                            prev_mask = seq_mask
                        else:
                            if seq_mask == 0xFF:
                                diff = (sequence - prev_seq) & 0xFF
                                seq_range = 0x100
                            else:
                                diff = (sequence - prev_seq) & 0xFFFFFFFF
                                seq_range = 0x100000000
                            if diff == 0:
                                prev_seq = sequence
                            elif diff < (seq_range // 2):
                                if diff > 1:
                                    pklost += diff - 1
                                prev_seq = sequence
                            else:
                                prev_seq = sequence
                    else:
                        prev_seq = None
                        prev_mask = None

                    if send_time is not None:
                        latency = receive_time - send_time
                        last_latency = latency if latency >= 0 else None
                    else:
                        last_latency = None

                    if last_latency is not None:
                        delay_sum_interval += last_latency
                        delay_count_interval += 1
                        delay_min_interval = (
                            last_latency
                            if delay_min_interval is None
                            else min(delay_min_interval, last_latency)
                        )
                        delay_max_interval = (
                            last_latency
                            if delay_max_interval is None
                            else max(delay_max_interval, last_latency)
                        )

                    elapsed = receive_time - time_int
                    if elapsed >= 1:
                        pkts = i - i_int
                        lost_period = pklost - lost_interval_base
                        expected = pkts + lost_period
                        quality = (pkts / expected) * 100 if expected > 0 else 100.0
                        bitrate = (bytes_interval * 8) / elapsed if elapsed > 0 else 0.0
                        delay_avg = (
                            delay_sum_interval / delay_count_interval
                            if delay_count_interval
                            else None
                        )
                        live.update(
                            status_line(
                                sequence_display,
                                i,
                                pkts,
                                interval,
                                packet_size,
                                lost_period,
                                pklost,
                                bitrate,
                                quality,
                                delay_avg,
                                delay_min_interval,
                                delay_max_interval,
                                last_latency,
                            )
                        )
                        i_int = i
                        time_int = receive_time
                        lost_interval_base = pklost
                        bytes_interval = 0
                        delay_sum_interval = 0.0
                        delay_count_interval = 0
                        delay_min_interval = None
                        delay_max_interval = None
        elif MODE==2:
            time_start = clock()
            time_pp = time_start
            time_int = time_start
            bytes_interval = 0
            with Live(status_line2(0, 0, 0, 0, 0, 0, 0), refresh_per_second=4) as live:
                stream_size = 0
                apkt_size = 0
                while True:
                    if select.select([sys.stdin], [], [], 0)[0]:  # check input
                        c = sys.stdin.read(1)  # read char
                        if c == '\x18':  # if ctrl^x
                            live.console.log("UDP-RX finished")
                            end_time = clock()
                            duration = end_time - time_start
                            rate = i / duration if duration > 0 else 0
                            live.console.print()
                            live.console.log("pkt: ", i, "\n")
                            live.console.log("avg pkt/s: ", f"{rate:.2f}")
                            break
                    packet, addr = sock.recvfrom(MAX_PACKET_SIZE)
                    packet_size = len(packet)

                    stream_size += packet_size
                    current_count = i + 1
                    apkt_size = stream_size / current_count if current_count else 0
                    bytes_interval += packet_size

                    if packet_size <= pksize_min:
                        pksize_min = packet_size
                    if packet_size >= pksize_max:
                        pksize_max = packet_size

                    receive_time = clock()
                    interval = receive_time - time_pp
                    time_pp = receive_time
                    i += 1
                    elapsed = receive_time - time_int
                    if elapsed >= 1:
                        pkts = i - i_int
                        bitrate = (bytes_interval * 8) / elapsed if elapsed > 0 else 0.0
                        live.update(status_line2(i, pkts, interval, pksize_min, pksize_max, apkt_size, bitrate))
                        i_int = i
                        time_int = receive_time
                        bytes_interval = 0
        else:
            console.log("[bold red]Error:[/] undefine mode, use --help for more info")
                    
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)  # return terminal settings
        
if __name__ == '__main__':
    main()
