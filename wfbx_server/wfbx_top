#!/usr/bin/env python3

import atexit
import selectors
import signal
import socket
import sys
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import click
from rich import box
from rich.align import Align
from rich.columns import Columns
from rich.console import Console, Group
from rich.live import Live
from rich.panel import Panel
from rich.table import Table
from rich.text import Text

from wfbxlib.stats import core as stats_core
from wfbxlib.stats import mx as stats_mx
from wfbxlib.stats import tx as stats_tx

console = Console()

@dataclass
class ModuleRecord:
    key: str
    kind: str
    header: stats_core.Header
    summary: Optional[stats_core.Summary]
    text_preview: Optional[str]
    tx_entries: List[stats_mx.TxSummary]
    if_entries: List[stats_mx.IfDetail]
    global_debug: Optional[stats_mx.GlobalDebug]
    tx_summary: Optional[stats_tx.Summary]
    tx_queue: Optional[stats_tx.QueueStats]
    tx_slot: Optional[stats_tx.SlotStats]
    tx_epoch: Optional[stats_tx.EpochStats]
    last_update: float


def create_mcast_socket(group_ip: str, port: int) -> socket.socket:
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        sock.bind(("", port))
    except OSError:
        sock.bind((group_ip, port))
    group_bin = socket.inet_aton(group_ip)
    iface_bins: List[bytes] = [socket.inet_aton("0.0.0.0")]
    try:
        iface_bins.append(socket.inet_aton("127.0.0.1"))
    except OSError:
        pass
    for iface_bin in iface_bins:
        mreq = group_bin + iface_bin
        try:
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
        except OSError:
            continue
    sock.setblocking(False)
    return sock


def parse_sections(header: stats_core.Header, sections: List[Tuple[int, bytes]]):
    summary: Optional[stats_core.Summary] = None
    text_preview: Optional[str] = None
    tx_entries: List[stats_mx.TxSummary] = []
    if_entries: List[stats_mx.IfDetail] = []
    global_debug: Optional[stats_mx.GlobalDebug] = None
    tx_summary: Optional[stats_tx.Summary] = None
    tx_queue: Optional[stats_tx.QueueStats] = None
    tx_slot: Optional[stats_tx.SlotStats] = None
    tx_epoch: Optional[stats_tx.EpochStats] = None

    for section_type, payload in sections:
        if section_type == stats_core.SectionType.SUMMARY:
            try:
                summary = stats_core.Summary.unpack(payload)
            except ValueError:
                continue
        elif section_type == stats_core.SectionType.TEXT_PREVIEW:
            text_preview = payload.rstrip(b"\0").decode("utf-8", "ignore")
        elif header.module_type == stats_core.ModuleType.MX:
            try:
                mx_type = stats_mx.SectionType(section_type)
            except ValueError:
                continue
            if mx_type == stats_mx.SectionType.TX_SUMMARY:
                try:
                    tx_entries = stats_mx.unpack_tx_summary_section(payload)
                except ValueError:
                    tx_entries = []
            elif mx_type == stats_mx.SectionType.IF_DETAIL:
                try:
                    if_entries = stats_mx.unpack_if_detail_section(payload)
                except ValueError:
                    if_entries = []
            elif mx_type == stats_mx.SectionType.GLOBAL_DEBUG:
                try:
                    global_debug = stats_mx.GlobalDebug.unpack(payload)
                except ValueError:
                    global_debug = None
        elif header.module_type == stats_core.ModuleType.TX:
            try:
                tx_type = stats_tx.SectionType(section_type)
            except ValueError:
                continue
            if tx_type == stats_tx.SectionType.SUMMARY:
                try:
                    tx_summary = stats_tx.Summary.unpack(payload)
                except ValueError:
                    tx_summary = None
            elif tx_type == stats_tx.SectionType.QUEUE:
                try:
                    tx_queue = stats_tx.QueueStats.unpack(payload)
                except ValueError:
                    tx_queue = None
            elif tx_type == stats_tx.SectionType.SLOT:
                try:
                    tx_slot = stats_tx.SlotStats.unpack(payload)
                except ValueError:
                    tx_slot = None
            elif tx_type == stats_tx.SectionType.EPOCH:
                try:
                    tx_epoch = stats_tx.EpochStats.unpack(payload)
                except ValueError:
                    tx_epoch = None

    return (
        summary,
        text_preview,
        tx_entries,
        if_entries,
        global_debug,
        tx_summary,
        tx_queue,
        tx_slot,
        tx_epoch,
    )


def detect_kind(header: stats_core.Header) -> str:
    module_id = (header.module_id or "").lower()
    if header.module_type == stats_core.ModuleType.MX:
        return "mx"
    if module_id.startswith("xtx"):
        return "xtx"
    if module_id.startswith("xrx"):
        return "xrx"
    if module_id.startswith("rxx"):
        return "rxx"
    if header.module_type == stats_core.ModuleType.TX:
        return "tx"
    if header.module_type == stats_core.ModuleType.RX:
        return "rx"
    return "unknown"


def build_record(datagram: bytes, now: float) -> ModuleRecord:
    header, sections = stats_core.decode_packet(datagram, verify_crc=False)
    (
        summary,
        text_preview,
        tx_entries,
        if_entries,
        global_debug,
        tx_summary,
        tx_queue,
        tx_slot,
        tx_epoch,
    ) = parse_sections(header, sections)
    host_id = header.host_id or "unknown"
    module_id = header.module_id or "unknown"
    key = f"{module_id}@{host_id}"
    kind = detect_kind(header)
    return ModuleRecord(
        key=key,
        kind=kind,
        header=header,
        summary=summary,
        text_preview=text_preview,
        tx_entries=tx_entries,
        if_entries=if_entries,
        global_debug=global_debug,
        tx_summary=tx_summary,
        tx_queue=tx_queue,
        tx_slot=tx_slot,
        tx_epoch=tx_epoch,
        last_update=now,
    )


def matches_filters(record: ModuleRecord,
                    module_id_filter: str,
                    module_type_filter: str,
                    host_id_filter: str) -> bool:
    module_id = record.header.module_id or ""
    host_id = record.header.host_id or ""
    if module_id_filter and module_id_filter.lower() not in module_id.lower():
        return False
    if host_id_filter and host_id_filter.lower() not in host_id.lower():
        return False
    if module_type_filter:
        mt = record.kind.lower()
        mt_name = record.header.module_type.name.lower()
        filt = module_type_filter.lower()
        if filt not in mt and filt not in mt_name:
            return False
    return True


def prune_stale(modules: Dict[str, ModuleRecord], now: float, idle_sec: float) -> None:
    stale = [key for key, rec in modules.items() if now - rec.last_update > idle_sec]
    for key in stale:
        modules.pop(key, None)


def render_summary_table(record: ModuleRecord) -> Table:
    table = Table.grid(expand=True)
    table.add_column(justify="left", style="cyan")
    table.add_column(justify="right", style="bold")
    table.add_row("Host", record.header.host_id or "-")
    table.add_row("Tick", str(record.header.tick_id))
    table.add_row("Flags", f"0x{record.header.flags:04X}")
    if record.summary is not None:
        summary = record.summary
        table.add_row("Window ms", str(summary.dt_ms))
        table.add_row("Packets", str(summary.packets_total))
        table.add_row("Bytes", str(summary.bytes_total))
        table.add_row("Interfaces", str(summary.iface_count))
        table.add_row("TX count", str(summary.tx_count))
    else:
        table.add_row("Summary", "n/a")
    return table


def render_mx(record: ModuleRecord) -> Group:
    blocks: List = []
    summary = record.summary
    if summary is not None:
        summary_line = Text()
        summary_line.append("pkts ")
        summary_line.append(f"{summary.packets_total}", style="bright_cyan")
        summary_line.append("  ctrl_epoch ")
        summary_line.append(f"{summary.ctrl_epoch_sent}", style="bright_cyan")
        summary_line.append("  tx ")
        summary_line.append(f"{summary.tx_count}", style="bright_cyan")
        summary_line.append("  ifaces ")
        summary_line.append(f"{summary.iface_count}", style="bright_cyan")
    else:
        summary_line = Text("summary unavailable", style="dim")
    blocks.append(summary_line)

    if record.tx_entries:
        dt_ms = summary.dt_ms if summary and summary.dt_ms > 0 else 1000
        width = console.size.width if console.size.width else 40
        width = max(10, width - 4)
        blocks.append(Text("·" * width, style="magenta"))
        for entry in record.tx_entries:
            tx_table = Table(
                show_header=True,
                header_style="magenta",
                expand=True,
                box=None,
                padding=(0, 1),
            )
            tx_table.add_column("tx", justify="right")
            tx_table.add_column("pkts/s", justify="right")
            tx_table.add_column("lost", justify="right")
            tx_table.add_column("rate kbps", justify="right")
            tx_table.add_column("rssi", justify="right")
            tx_table.add_column("signal", justify="center")
            tx_table.add_column("qlt %", justify="right")

            pkts_per_sec = entry.packets * 1000.0 / dt_ms if dt_ms > 0 else float(entry.packets)
            rssi = entry.rssi_q8 / 256.0
            quality = entry.quality_permille / 10.0
            if quality >= 97.0:
                quality_style = "bright_green"
            elif quality >= 90.0:
                quality_style = "yellow"
            else:
                quality_style = "bright_red"
            tx_table.add_row(
                f"{entry.tx_id}",
                f"{pkts_per_sec:.1f}",
                f"{entry.lost}",
                f"{entry.rate_kbps}",
                f"{rssi:.1f}",
                render_signal_bar_text(rssi),
                Text(f"{quality:.1f}", style=quality_style),
            )

            blocks.append(tx_table)

            # Antenna-level detail for this TX
            chain_rows: List[List[object]] = []
            for if_entry in record.if_entries:
                if if_entry.tx_id != entry.tx_id:
                    continue
                iface_id = if_entry.iface_id
                for chain in if_entry.chains:
                    chain_quality = chain.quality_permille / 10.0
                    chain_rssi = chain.rssi_avg_q8 / 256.0
                    chain_rows.append(
                        [
                            f"{iface_id}",
                            f"{chain.ant_id}",
                            f"{chain.packets}",
                            f"{chain.lost}",
                            f"{chain_rssi:.1f}",
                            render_signal_bar_text(chain_rssi, glyph="❘"),
                            f"{chain_quality:.1f}"
                        ]
                    )

            if chain_rows:
                chain_table = Table(
                    show_header=True,
                    header_style="cyan",
                    expand=True,
                    box=None,
                    padding=(0, 1),
                )
                chain_table.add_column("if", justify="right")
                chain_table.add_column("ant", justify="right")
                chain_table.add_column("pkts", justify="right")
                chain_table.add_column("lost", justify="right")
                chain_table.add_column("rssi", justify="right")
                chain_table.add_column("signal", justify="center")
                chain_table.add_column("qlt %", justify="right")
                for row in chain_rows:
                    styled_row = [
                        Text(row[0], style="bright_black"),
                        Text(row[1], style="bright_black"),
                        Text(row[2], style="bright_black"),
                        Text(row[3], style="bright_black"),
                        Text(row[4], style="bright_black"),
                        row[5],
                        Text(row[6], style="bright_black"),
                    ]
                    chain_table.add_row(*styled_row)
                blocks.append(chain_table)
            blocks.append(Text(""))

    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))
    return Group(*blocks)


def render_tx(record: ModuleRecord) -> Group:
    blocks: List = [render_summary_table(record)]

    if record.tx_summary is not None:
        ts = record.tx_summary
        throughput_table = Table.grid(expand=True)
        throughput_table.add_column(style="cyan", justify="left")
        throughput_table.add_column(style="bright_white", justify="right")
        throughput_table.add_row("window ms", str(ts.dt_ms))
        throughput_table.add_row("udp rx pkts", f"{ts.udp_rx_packets}")
        throughput_table.add_row("udp rx kbps", f"{ts.udp_rx_kbps_x10 / 10.0:.1f}")
        throughput_table.add_row("sent pkts", f"{ts.sent_packets}")
        throughput_table.add_row("sent kbps", f"{ts.sent_kbps_x10 / 10.0:.1f}")
        throughput_table.add_row("drop overflow", f"{ts.drop_overflow}")
        blocks.append(Panel(throughput_table, title="throughput", border_style="magenta"))
    else:
        blocks.append(Text("TX summary unavailable", style="dim"))

    if record.tx_queue is not None:
        tq = record.tx_queue
        queue_table = Table.grid(expand=True)
        queue_table.add_column(style="cyan", justify="left")
        queue_table.add_column(style="bright_white", justify="right")
        queue_table.add_row("avg", str(tq.avg))
        queue_table.add_row("min", str(tq.min))
        queue_table.add_row("max", str(tq.max))
        queue_table.add_row("samples", str(tq.samples))
        blocks.append(Panel(queue_table, title="queue depth", border_style="green"))

    if record.tx_slot is not None:
        tslt = record.tx_slot
        slot_table = Table.grid(expand=True)
        slot_table.add_column(style="cyan", justify="left")
        slot_table.add_column(style="bright_white", justify="right")
        slot_table.add_row("avg", str(tslt.avg))
        slot_table.add_row("min", str(tslt.min))
        slot_table.add_row("max", str(tslt.max))
        slot_table.add_row("slots", str(tslt.slots))
        blocks.append(Panel(slot_table, title="slot sent", border_style="yellow"))

    if record.tx_epoch is not None:
        te = record.tx_epoch
        epoch_table = Table.grid(expand=True)
        epoch_table.add_column(style="cyan", justify="left")
        epoch_table.add_column(style="bright_white", justify="right")
        epoch_table.add_row("e_epoch_base_us", str(te.e_epoch_base_us))
        epoch_table.add_row("mx_epoch_msgs", str(te.mx_epoch_msgs))
        epoch_table.add_row("base_adv", str(te.base_adv))
        epoch_table.add_row("base_step_avg_us", str(te.base_step_avg_us))
        epoch_table.add_row("base_step_min_us", str(te.base_step_min_us))
        epoch_table.add_row("base_step_max_us", str(te.base_step_max_us))
        epoch_table.add_row("base_step_samples", str(te.base_step_samples))
        epoch_table.add_row("epoch_adj_count", str(te.epoch_adj_count))
        epoch_table.add_row("epoch_adj_avg_us", str(te.epoch_adj_avg_us))
        epoch_table.add_row("epoch_adj_min_us", str(te.epoch_adj_min_us))
        epoch_table.add_row("epoch_adj_max_us", str(te.epoch_adj_max_us))
        blocks.append(Panel(epoch_table, title="epoch control", border_style="blue"))

    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))

    return Group(*blocks)


def render_generic(record: ModuleRecord, label: str) -> Group:
    blocks: List = [render_summary_table(record)]
    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))
    return Group(*blocks)


_SIGNAL_THRESHOLDS = (
    -80.0, -75.0, -74.0, -73.0, -72.0,
    -71.0, -70.0, -71.0, -70.0, -69.0,
    -68.0, -66.0, -64.0, -62.0, -60.0,
    -58.0, -56.0, -54.0, -52.0, -50.0,
    -45.0, -35.0, -25.0, -5.0, 16.0,
)

#[∣❘❙❚¦•]
def render_signal_bar_text(rssi: float, glyph: str = "❘") -> Text:
    markup = stats_core.render_signal_bar(
        rssi,
        thresholds=_SIGNAL_THRESHOLDS,
        glyph_active=glyph,
    )
    return Text.from_markup(markup)


def render_module(record: ModuleRecord, now: float) -> Panel:
    age = now - record.last_update
    if record.kind == "mx":
        host = record.header.host_id or "-"
        module = record.header.module_id or "unknown"
        title = f"{host}.{module}"
    else:
        title = f"{record.header.module_id or 'unknown'} [{record.kind}]"
    subtitle = f"age {age:0.1f}s"
    if record.kind == "mx":
        body = render_mx(record)
    elif record.kind in {"rx", "xrx", "rxx"}:
        body = render_generic(record, "rx")
    elif record.kind in {"tx", "xtx"}:
        body = render_tx(record)
    else:
        body = render_generic(record, "stat")
    return Panel(body, title=title, subtitle=subtitle, border_style="green")


def render_dashboard(modules: Dict[str, ModuleRecord], now: float) -> Panel:
    if not modules:
        return Panel(Align.center(Text("Awaiting telemetry...", style="dim"), vertical="middle"), border_style="blue")
    ordered = [modules[key] for key in sorted(modules.keys())]
    panels = [render_module(rec, now) for rec in ordered]
    return Panel(Columns(panels, expand=True), border_style="blue", title="wfbx_top")


@click.command()
@click.option("--ip", "mcast_ip", default="239.255.0.1", show_default=True, help="Multicast group IP")
@click.option("--port", default=9100, type=int, show_default=True, help="Multicast group port")
@click.option("--idle-ms", default=4000, type=int, show_default=True, help="Evict module if idle longer than this (ms)")
@click.option("--module-id", "module_id_filter", default="", help="Substring filter for module_id")
@click.option("--module-type", "module_type_filter", default="", help="Substring filter for module_type")
@click.option("--host-id", "host_id_filter", default="", help="Substring filter for host_id")
def main(mcast_ip: str,
         port: int,
         idle_ms: int,
         module_id_filter: str,
         module_type_filter: str,
         host_id_filter: str) -> None:
    sock: Optional[socket.socket] = None

    def cleanup() -> None:
        if sock is not None:
            try:
                sock.close()
            except Exception:
                pass

    def handle_signal(_sig, _frame) -> None:
        cleanup()
        sys.exit(0)

    atexit.register(cleanup)
    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    modules: Dict[str, ModuleRecord] = {}
    idle_sec = idle_ms / 1000.0 if idle_ms > 0 else float("inf")

    sock = create_mcast_socket(mcast_ip, port)
    selector = selectors.DefaultSelector()
    selector.register(sock, selectors.EVENT_READ)

    total_packets = 0
    filtered_packets = 0

    with Live(render_dashboard(modules, time.time()), refresh_per_second=5, console=console) as live:
        while True:
            events = selector.select(timeout=0.5)
            now = time.time()
            for key, _mask in events:
                if key.fileobj is not sock:
                    continue
                while True:
                    try:
                        datagram, _addr = sock.recvfrom(65535)
                    except BlockingIOError:
                        break
                    except OSError:
                        break
                    if not datagram:
                        continue
                    total_packets += 1
                    console.log(f"[TOP] received datagram len={len(datagram)} total={total_packets}")
                    try:
                        record = build_record(datagram, now)
                    except Exception as exc:
                        console.log(f"[TOP] decode failed: {exc}")
                        continue
                    if not matches_filters(record, module_id_filter, module_type_filter, host_id_filter):
                        filtered_packets += 1
                        console.log(f"[TOP] filtered module_id={record.header.module_id} host_id={record.header.host_id}")
                        continue
                    modules[record.key] = record
            prune_stale(modules, now, idle_sec)
            live.update(render_dashboard(modules, now))


if __name__ == "__main__":
    main()
