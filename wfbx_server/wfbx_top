#!/usr/bin/env python3

import atexit
import selectors
import signal
import socket
import sys
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import click
from rich import box
from rich.align import Align
from rich.columns import Columns
from rich.console import Console, Group
from rich.live import Live
from rich.panel import Panel
from rich.table import Table
from rich.text import Text

from wfbxlib.stats import core as stats_core
from wfbxlib.stats import mx as stats_mx
from wfbxlib.stats import tx as stats_tx
from wfbxlib.stats import rx as stats_rx

console = Console()

@dataclass
class ModuleRecord:
    key: str
    kind: str
    header: stats_core.Header
    summary: Optional[stats_core.Summary]
    text_preview: Optional[str]
    tx_entries: List[stats_mx.TxSummary]
    if_entries: List[stats_mx.IfDetail]
    global_debug: Optional[stats_mx.GlobalDebug]
    mx_filter: Optional[stats_mx.FilterInfo]
    tx_summary: Optional[stats_tx.Summary]
    tx_queue: Optional[stats_tx.QueueStats]
    tx_slot: Optional[stats_tx.SlotStats]
    tx_epoch: Optional[stats_tx.EpochStats]
    rx_summary: Optional[stats_rx.Summary]
    rx_tx_entries: List[stats_rx.TxSummary]
    rx_if_entries: List[stats_rx.IfDetail]
    rx_filter: Optional[stats_rx.FilterInfo]
    last_update: float


def create_mcast_socket(group_ip: str, port: int) -> socket.socket:
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        sock.bind(("", port))
    except OSError:
        sock.bind((group_ip, port))
    group_bin = socket.inet_aton(group_ip)
    iface_bins: List[bytes] = [socket.inet_aton("0.0.0.0")]
    try:
        iface_bins.append(socket.inet_aton("127.0.0.1"))
    except OSError:
        pass
    for iface_bin in iface_bins:
        mreq = group_bin + iface_bin
        try:
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
        except OSError:
            continue
    sock.setblocking(False)
    return sock


def parse_sections(header: stats_core.Header, sections: List[Tuple[int, bytes]]):
    summary: Optional[stats_core.Summary] = None
    text_preview: Optional[str] = None
    tx_entries: List[stats_mx.TxSummary] = []
    if_entries: List[stats_mx.IfDetail] = []
    global_debug: Optional[stats_mx.GlobalDebug] = None
    mx_filter: Optional[stats_mx.FilterInfo] = None
    tx_summary: Optional[stats_tx.Summary] = None
    tx_queue: Optional[stats_tx.QueueStats] = None
    tx_slot: Optional[stats_tx.SlotStats] = None
    tx_epoch: Optional[stats_tx.EpochStats] = None
    rx_summary: Optional[stats_rx.Summary] = None
    rx_tx_entries: List[stats_rx.TxSummary] = []
    rx_if_entries: List[stats_rx.IfDetail] = []
    rx_filter: Optional[stats_rx.FilterInfo] = None

    for section_type, payload in sections:
        if section_type == stats_core.SectionType.SUMMARY:
            try:
                summary = stats_core.Summary.unpack(payload)
            except ValueError:
                continue
        elif section_type == stats_core.SectionType.TEXT_PREVIEW:
            text_preview = payload.rstrip(b"\0").decode("utf-8", "ignore")
        elif header.module_type == stats_core.ModuleType.MX:
            try:
                mx_type = stats_mx.SectionType(section_type)
            except ValueError:
                continue
            if mx_type == stats_mx.SectionType.TX_SUMMARY:
                try:
                    tx_entries = stats_mx.unpack_tx_summary_section(payload)
                except ValueError:
                    tx_entries = []
            elif mx_type == stats_mx.SectionType.IF_DETAIL:
                try:
                    if_entries = stats_mx.unpack_if_detail_section(payload)
                except ValueError:
                    if_entries = []
            elif mx_type == stats_mx.SectionType.GLOBAL_DEBUG:
                try:
                    global_debug = stats_mx.GlobalDebug.unpack(payload)
                except ValueError:
                    global_debug = None
            elif mx_type == stats_mx.SectionType.FILTER_INFO:
                try:
                    mx_filter = stats_mx.FilterInfo.unpack(payload)
                except ValueError:
                    mx_filter = None
        elif header.module_type == stats_core.ModuleType.RX:
            try:
                rx_type = stats_rx.SectionType(section_type)
            except ValueError:
                continue
            if rx_type == stats_rx.SectionType.SUMMARY:
                try:
                    rx_summary = stats_rx.Summary.unpack(payload)
                except ValueError:
                    rx_summary = None
            elif rx_type == stats_rx.SectionType.TX_SUMMARY:
                try:
                    rx_tx_entries = stats_rx.unpack_tx_summary_section(payload)
                except ValueError:
                    rx_tx_entries = []
            elif rx_type == stats_rx.SectionType.IF_DETAIL:
                try:
                    rx_if_entries = stats_rx.unpack_if_detail_section(payload)
                except ValueError:
                    rx_if_entries = []
            elif rx_type == stats_rx.SectionType.FILTERS:
                try:
                    rx_filter = stats_rx.unpack_filter_section(payload)
                except ValueError:
                    rx_filter = None
        elif header.module_type == stats_core.ModuleType.TX:
            try:
                tx_type = stats_tx.SectionType(section_type)
            except ValueError:
                continue
            if tx_type == stats_tx.SectionType.SUMMARY:
                try:
                    tx_summary = stats_tx.Summary.unpack(payload)
                except ValueError:
                    tx_summary = None
            elif tx_type == stats_tx.SectionType.QUEUE:
                try:
                    tx_queue = stats_tx.QueueStats.unpack(payload)
                except ValueError:
                    tx_queue = None
            elif tx_type == stats_tx.SectionType.SLOT:
                try:
                    tx_slot = stats_tx.SlotStats.unpack(payload)
                except ValueError:
                    tx_slot = None
            elif tx_type == stats_tx.SectionType.EPOCH:
                try:
                    tx_epoch = stats_tx.EpochStats.unpack(payload)
                except ValueError:
                    tx_epoch = None

    return (
        summary,
        text_preview,
        tx_entries,
        if_entries,
        global_debug,
        mx_filter,
        tx_summary,
        tx_queue,
        tx_slot,
        tx_epoch,
        rx_summary,
        rx_tx_entries,
        rx_if_entries,
        rx_filter,
    )


def detect_kind(header: stats_core.Header) -> str:
    module_id = (header.module_id or "").lower()
    if header.module_type == stats_core.ModuleType.MX:
        return "mx"
    if module_id.startswith("xtx"):
        return "xtx"
    if module_id.startswith("xrx"):
        return "xrx"
    if module_id.startswith("rxx"):
        return "rxx"
    if header.module_type == stats_core.ModuleType.TX:
        return "tx"
    if header.module_type == stats_core.ModuleType.RX:
        return "rx"
    return "unknown"


def build_record(datagram: bytes, now: float) -> ModuleRecord:
    header, sections = stats_core.decode_packet(datagram, verify_crc=False)
    (
        summary,
        text_preview,
        tx_entries,
        if_entries,
        global_debug,
        mx_filter,
        tx_summary,
        tx_queue,
        tx_slot,
        tx_epoch,
        rx_summary,
        rx_tx_entries,
        rx_if_entries,
        rx_filter,
    ) = parse_sections(header, sections)
    host_id = header.host_id or "unknown"
    module_id = header.module_id or "unknown"
    key = f"{module_id}@{host_id}"
    kind = detect_kind(header)
    return ModuleRecord(
        key=key,
        kind=kind,
        header=header,
        summary=summary,
        text_preview=text_preview,
        tx_entries=tx_entries,
        if_entries=if_entries,
        global_debug=global_debug,
        mx_filter=mx_filter,
        tx_summary=tx_summary,
        tx_queue=tx_queue,
        tx_slot=tx_slot,
        tx_epoch=tx_epoch,
        rx_summary=rx_summary,
        rx_tx_entries=rx_tx_entries,
        rx_if_entries=rx_if_entries,
        rx_filter=rx_filter,
        last_update=now,
    )


def matches_filters(record: ModuleRecord,
                    module_id_filter: str,
                    module_type_filter: str,
                    host_id_filter: str) -> bool:
    module_id = record.header.module_id or ""
    host_id = record.header.host_id or ""
    if module_id_filter and module_id_filter.lower() not in module_id.lower():
        return False
    if host_id_filter and host_id_filter.lower() not in host_id.lower():
        return False
    if module_type_filter:
        mt = record.kind.lower()
        mt_name = record.header.module_type.name.lower()
        filt = module_type_filter.lower()
        if filt not in mt and filt not in mt_name:
            return False
    return True


def prune_stale(modules: Dict[str, ModuleRecord], now: float, idle_sec: float) -> None:
    stale = [key for key, rec in modules.items() if now - rec.last_update > idle_sec]
    for key in stale:
        modules.pop(key, None)


def render_summary_table(record: ModuleRecord) -> Table:
    table = Table.grid(expand=True)
    table.add_column(justify="left", style="cyan")
    table.add_column(justify="right", style="bold")
    table.add_row("Host", record.header.host_id or "-")
    table.add_row("Tick", str(record.header.tick_id))
    table.add_row("Flags", f"0x{record.header.flags:04X}")
    if record.summary is not None:
        summary = record.summary
        table.add_row("Window ms", str(summary.dt_ms))
        table.add_row("Packets", str(summary.packets_total))
        if summary.dt_ms > 0:
            rate = (summary.bytes_total * 8.0) / summary.dt_ms
            table.add_row("Rate kbps", f"{rate:.1f}")
        else:
            table.add_row("Rate kbps", "-")
        table.add_row("Interfaces", str(summary.iface_count))
        table.add_row("TX count", str(summary.tx_count))
    elif record.rx_summary is not None:
        summary = record.rx_summary
        table.add_row("Window ms", str(summary.dt_ms))
        table.add_row("Packets", str(summary.packets_total))
        if summary.dt_ms > 0:
            rate = (summary.bytes_total * 8.0) / summary.dt_ms
            table.add_row("Rate kbps", f"{rate:.1f}")
        else:
            table.add_row("Rate kbps", "-")
        table.add_row("Interfaces", str(summary.iface_count))
        table.add_row("TX count", str(summary.tx_count))
        table.add_row("Filter flags", f"0x{summary.filter_flags:04X}")
        if record.rx_filter is not None:
            filt = record.rx_filter
            txf_mode = {0: "any", 1: "include", 2: "exclude"}.get(filt.txf_mode, str(filt.txf_mode))
            spec = filt.txf_spec or "-"
            table.add_row("TX filter", f"{txf_mode}: {spec}")
            table.add_row("Group filter", str(filt.group_id) if filt.group_id != 0xFF else "any")
            if filt.has_link_id:
                table.add_row("Link filter", str(filt.link_id))
            else:
                table.add_row("Link filter", "any")
            if filt.has_radio_port:
                table.add_row("Radio filter", str(filt.radio_port))
            else:
                table.add_row("Radio filter", "any")
    else:
        table.add_row("Summary", "n/a")
    return table


def render_mx(record: ModuleRecord) -> Group:
    blocks: List = []
    summary = record.summary
    headers = ["pkts", "ctrl_epoch", "tx", "ifaces", "group_id", "tx_id"]
    info_table = Table(box=None, show_header=False, expand=True, padding=(0, 1))
    info_table.add_row(*[Text(label, style="cyan") for label in headers])

    pkts_val = f"{summary.packets_total}" if summary is not None else "n/a"
    ctrl_epoch_val = f"{summary.ctrl_epoch_sent}" if summary is not None else "n/a"
    tx_val = f"{summary.tx_count}" if summary is not None else "n/a"
    ifaces_val = f"{summary.iface_count}" if summary is not None else "n/a"

    if record.mx_filter is not None:
        filt = record.mx_filter
        group_val = "any" if filt.group_id < 0 else str(filt.group_id)
        tx_spec = filt.tx_filter_spec or "any"
    else:
        group_val = "any"
        tx_spec = "any"

    info_table.add_row(pkts_val, ctrl_epoch_val, tx_val, ifaces_val, group_val, tx_spec)
    blocks.append(info_table)

    if record.tx_entries:
        dt_ms = summary.dt_ms if summary and summary.dt_ms > 0 else 1000
        for entry in record.tx_entries:
            tx_table = Table(
                show_header=True,
                header_style="magenta",
                expand=True,
                box=None,
                padding=(0, 1),
            )
            tx_table.add_column("tx", justify="right")
            tx_table.add_column("pkts/s", justify="right")
            tx_table.add_column("lost", justify="right")
            tx_table.add_column("rate kbps", justify="right")
            tx_table.add_column("rssi", justify="right")
            tx_table.add_column("signal", justify="center")
            tx_table.add_column("qlt %", justify="right")

            pkts_per_sec = entry.packets * 1000.0 / dt_ms if dt_ms > 0 else float(entry.packets)
            rssi = entry.rssi_q8 / 256.0
            quality = entry.quality_permille / 10.0
            if quality >= 97.0:
                quality_style = "bright_green"
            elif quality >= 90.0:
                quality_style = "yellow"
            else:
                quality_style = "bright_red"
            tx_table.add_row(
                f"{entry.tx_id}",
                f"{pkts_per_sec:.1f}",
                f"{entry.lost}",
                f"{entry.rate_kbps}",
                f"{rssi:.1f}",
                render_signal_bar_text(rssi),
                Text(f"{quality:.1f}", style=quality_style),
            )

            blocks.append(tx_table)

            # Antenna-level detail for this TX
            chain_rows: List[List[object]] = []
            for if_entry in record.if_entries:
                if if_entry.tx_id != entry.tx_id:
                    continue
                iface_id = if_entry.iface_id
                freq_text = f"{if_entry.freq_mhz}" if getattr(if_entry, "freq_mhz", 0) else "-"
                for chain in if_entry.chains:
                    chain_quality = chain.quality_permille / 10.0
                    chain_rssi = chain.rssi_avg_q8 / 256.0
                    chain_rows.append(
                        [
                            f"{iface_id}",
                            freq_text,
                            f"{chain.ant_id}",
                            f"{chain.packets}",
                            f"{chain.lost}",
                            f"{chain_rssi:.1f}",
                            render_signal_bar_text(chain_rssi, glyph="❘"),
                            f"{chain_quality:.1f}"
                        ]
                    )

            if chain_rows:
                chain_table = Table(
                    show_header=True,
                    header_style="cyan",
                    expand=True,
                    box=None,
                    padding=(0, 1),
                )
                chain_table.add_column("if", justify="right")
                chain_table.add_column("freq", justify="right")
                chain_table.add_column("ant", justify="right")
                chain_table.add_column("pkts", justify="right")
                chain_table.add_column("lost", justify="right")
                chain_table.add_column("rssi", justify="right")
                chain_table.add_column("signal", justify="center")
                chain_table.add_column("qlt %", justify="right")
                for row in chain_rows:
                    styled_row = [
                        Text(row[0], style="bright_black"),
                        Text(row[1], style="bright_black"),
                        Text(row[2], style="bright_black"),
                        Text(row[3], style="bright_black"),
                        Text(row[4], style="bright_black"),
                        Text(row[5], style="bright_black"),
                        row[6],
                        Text(row[7], style="bright_black"),
                    ]
                    chain_table.add_row(*styled_row)
                blocks.append(chain_table)
            blocks.append(Text(""))

    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))
    return Group(*blocks)


def _two_row_table(labels: List[str], values: List[str], *, style_label: str = "cyan", style_value: str = "bright_white") -> Table:
    table = Table(box=None, show_header=False, expand=True, padding=(0, 1))
    table.add_row(*[Text(label, style=style_label) for label in labels])
    table.add_row(*[Text(val, style=style_value) for val in values])
    return table


def render_tx(record: ModuleRecord) -> Group:
    blocks: List = []

    metrics_table = Table(box=None, show_header=False, expand=True, padding=(0, 1))
    columns = 5
    for _ in range(columns):
        metrics_table.add_column()
    metrics_added = False
    missing_summary = False

    if record.tx_summary is not None:
        ts = record.tx_summary
        labels = [
            "udp rx pkts",
            "udp rx kbps",
            "sent pkts",
            "sent kbps",
            "drop overflow",
        ]
        values = [
            f"{ts.udp_rx_packets}",
            f"{ts.udp_rx_kbps_x10 / 10.0:.1f}",
            f"{ts.sent_packets}",
            f"{ts.sent_kbps_x10 / 10.0:.1f}",
            f"{ts.drop_overflow}",
        ]
        metrics_table.add_row(*[Text(lbl, style="cyan") for lbl in labels])
        metrics_table.add_row(*[Text(val, style="bright_white") for val in values])
        metrics_added = True
    else:
        missing_summary = True

    if record.tx_queue is not None:
        tq = record.tx_queue
        labels = ["queue avg", "min", "max", "samples", ""]
        values = [str(tq.avg), str(tq.min), str(tq.max), str(tq.samples), ""]
        metrics_table.add_row(*[Text(lbl, style="cyan") if lbl else Text("") for lbl in labels])
        metrics_table.add_row(*[Text(val, style="bright_black") if val else Text("") for val in values])
        metrics_added = True

    if record.tx_slot is not None:
        tslt = record.tx_slot
        labels = ["slot avg", "min", "max", "slots", ""]
        values = [str(tslt.avg), str(tslt.min), str(tslt.max), str(tslt.slots), ""]
        metrics_table.add_row(*[Text(lbl, style="cyan") if lbl else Text("") for lbl in labels])
        metrics_table.add_row(*[Text(val, style="bright_black") if val else Text("") for val in values])
        metrics_added = True

    if metrics_added:
        blocks.append(metrics_table)
    if missing_summary:
        blocks.append(Text("TX summary unavailable", style="dim"))

    if record.tx_epoch is not None:
        te = record.tx_epoch
        labels = [
            "e_epoch",
            "mx_msgs",
            "step_smp",
            "adj_count",
            "adj_avg",
            "adj_min",
            "adj_max",
        ]
        values = [
            str(te.e_epoch_base_us),
            str(te.mx_epoch_msgs),
            str(te.base_step_samples),
            str(te.epoch_adj_count),
            str(te.epoch_adj_avg_us),
            str(te.epoch_adj_min_us),
            str(te.epoch_adj_max_us),
        ]
        blocks.append(_two_row_table(labels, values, style_label="blue", style_value="bright_black"))

    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))

    return Group(*blocks)


def render_rx(record: ModuleRecord) -> Group:
    blocks: List = []
    summary = record.rx_summary
    if summary is not None:
        labels = ["pkts", "rate(kbps)", "ifaces", "tx"]
        values = [
            f"{summary.packets_total}",
            f"{((summary.bytes_total * 8.0) / summary.dt_ms):.1f}" if summary.dt_ms > 0 else "n/a",
            f"{summary.iface_count}",
            f"{summary.tx_count}",
        ]
    else:
        labels = ["pkts", "rate(kbps)", "ifaces", "tx"]
        values = ["n/a", "n/a", "n/a", "n/a"]

    if record.rx_filter is not None:
        filt = record.rx_filter
        labels.extend(["group_id", "tx_id", "link_id", "radio_port"])
        values.extend([
            str(filt.group_id) if filt.group_id != 0xFF else "any",
            filt.txf_spec or "-",
            str(filt.link_id) if filt.has_link_id else "any",
            str(filt.radio_port) if filt.has_radio_port else "any",
        ])

    info_table = Table(box=None, show_header=False, expand=True, padding=(0, 1))
    info_table.add_row(*[Text(label, style="cyan") for label in labels])
    info_table.add_row(*values)
    blocks.append(info_table)

    dt_ms = summary.dt_ms if summary and summary.dt_ms > 0 else 1000

    if record.rx_tx_entries:
        tx_table = Table(
            show_header=True,
            header_style="magenta",
            expand=True,
            box=None,
            padding=(0, 1),
        )
        tx_table.add_column("tx", justify="right")
        tx_table.add_column("pkts/s", justify="right")
        tx_table.add_column("lost", justify="right")
        tx_table.add_column("rate kbps", justify="right")
        tx_table.add_column("rssi", justify="right")
        tx_table.add_column("signal", justify="center")
        tx_table.add_column("qlt %", justify="right")

        for entry in record.rx_tx_entries:
            pkts_per_sec = entry.packets * 1000.0 / dt_ms if dt_ms > 0 else float(entry.packets)
            rssi = entry.rssi_q8 / 256.0
            quality = entry.quality_permille / 10.0
            if quality >= 97.0:
                quality_style = "bright_green"
            elif quality >= 90.0:
                quality_style = "yellow"
            else:
                quality_style = "bright_red"
            tx_table.add_row(
                f"{entry.tx_id}",
                f"{pkts_per_sec:.1f}",
                f"{entry.lost}",
                f"{entry.rate_kbps}",
                f"{rssi:.1f}",
                render_signal_bar_text(rssi),
                Text(f"{quality:.1f}", style=quality_style),
            )

        blocks.append(tx_table)

        for entry in record.rx_tx_entries:
            chain_rows: List[List[object]] = []
            for if_entry in sorted(record.rx_if_entries, key=lambda d: (d.tx_id, d.iface_id)):
                if if_entry.tx_id != entry.tx_id:
                    continue
                freq_text = f"{if_entry.freq_mhz}" if if_entry.freq_mhz else "-"
                for chain in if_entry.chains:
                    chain_quality = chain.quality_permille / 10.0
                    chain_rssi = chain.rssi_avg_q8 / 256.0
                    chain_rows.append([
                        Text(str(if_entry.iface_id), style="bright_black"),
                        Text(freq_text, style="bright_black"),
                        Text(str(chain.ant_id), style="bright_black"),
                        Text(str(chain.packets), style="bright_black"),
                        Text(str(chain.lost), style="bright_black"),
                        Text(f"{chain_rssi:.1f}", style="bright_black"),
                        render_signal_bar_text(chain_rssi, glyph="❘"),
                        Text(f"{chain_quality:.1f}", style="bright_black"),
                    ])

            if chain_rows:
                chain_table = Table(
                    show_header=True,
                    header_style="cyan",
                    expand=True,
                    box=None,
                    padding=(0, 1),
                )
                chain_table.add_column("if", justify="right")
                chain_table.add_column("freq", justify="right")
                chain_table.add_column("ant", justify="right")
                chain_table.add_column("pkts", justify="right")
                chain_table.add_column("lost", justify="right")
                chain_table.add_column("rssi", justify="right")
                chain_table.add_column("signal", justify="center")
                chain_table.add_column("qlt %", justify="right")
                for row in chain_rows:
                    chain_table.add_row(*row)
                blocks.append(chain_table)
        blocks.append(Text(""))
    else:
        blocks.append(Text("no RX tx entries", style="dim"))

    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))

    return Group(*blocks)


def render_generic(record: ModuleRecord, label: str) -> Group:
    blocks: List = [render_summary_table(record)]
    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))
    return Group(*blocks)


_SIGNAL_THRESHOLDS = (
    -80.0, -75.0, -74.0, -73.0, -72.0,
    -71.0, -70.0, -71.0, -70.0, -69.0,
    -68.0, -66.0, -64.0, -62.0, -60.0,
    -58.0, -56.0, -54.0, -52.0, -50.0,
    -45.0, -35.0, -25.0, -5.0, 16.0,
)

#[∣❘❙❚¦•]
def render_signal_bar_text(rssi: float, glyph: str = "❘") -> Text:
    markup = stats_core.render_signal_bar(
        rssi,
        thresholds=_SIGNAL_THRESHOLDS,
        glyph_active=glyph,
    )
    return Text.from_markup(markup)


def render_module(record: ModuleRecord, now: float) -> Panel:
    age = now - record.last_update
    if record.kind == "mx":
        host = record.header.host_id or "-"
        module = record.header.module_id or "unknown"
        title = f"{host}.{module}"
    elif record.kind in {"tx", "xtx"}:
        host = record.header.host_id or "-"
        module = record.header.module_id or "unknown"
        title = f"{host}.{module}"
    elif record.kind in {"rx", "xrx", "rxx"}:
        host = record.header.host_id or "-"
        module = record.header.module_id or "unknown"
        title = f"{host}.{module}"
    else:
        title = f"{record.header.module_id or 'unknown'} [{record.kind}]"
    subtitle = f"age {age:0.1f}s"
    if record.kind == "mx":
        body = render_mx(record)
    elif record.kind in {"rx", "xrx", "rxx"}:
        body = render_rx(record)
    elif record.kind in {"tx", "xtx"}:
        body = render_tx(record)
    else:
        body = render_generic(record, "stat")
    return Panel(body, title=title, subtitle=subtitle, border_style="green")


def render_dashboard(modules: Dict[str, ModuleRecord], now: float) -> Panel:
    if not modules:
        return Panel(Align.center(Text("Awaiting telemetry...", style="dim"), vertical="middle"), border_style="blue")
    ordered = [modules[key] for key in sorted(modules.keys())]
    panels = [render_module(rec, now) for rec in ordered]
    return Panel(Columns(panels, expand=True), border_style="blue", title="wfbx_top")


@click.command()
@click.option("--ip", "mcast_ip", default="239.255.0.1", show_default=True, help="Multicast group IP")
@click.option("--port", default=9100, type=int, show_default=True, help="Multicast group port")
@click.option("--idle-ms", default=4000, type=int, show_default=True, help="Evict module if idle longer than this (ms)")
@click.option("--module-id", "module_id_filter", default="", help="Substring filter for module_id")
@click.option("--module-type", "module_type_filter", default="", help="Substring filter for module_type")
@click.option("--host-id", "host_id_filter", default="", help="Substring filter for host_id")
def main(mcast_ip: str,
         port: int,
         idle_ms: int,
         module_id_filter: str,
         module_type_filter: str,
         host_id_filter: str) -> None:
    sock: Optional[socket.socket] = None

    def cleanup() -> None:
        if sock is not None:
            try:
                sock.close()
            except Exception:
                pass

    def handle_signal(_sig, _frame) -> None:
        cleanup()
        sys.exit(0)

    atexit.register(cleanup)
    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    modules: Dict[str, ModuleRecord] = {}
    idle_sec = idle_ms / 1000.0 if idle_ms > 0 else float("inf")

    sock = create_mcast_socket(mcast_ip, port)
    selector = selectors.DefaultSelector()
    selector.register(sock, selectors.EVENT_READ)

    total_packets = 0
    filtered_packets = 0

    with Live(render_dashboard(modules, time.time()), refresh_per_second=5, console=console) as live:
        while True:
            events = selector.select(timeout=0.5)
            now = time.time()
            for key, _mask in events:
                if key.fileobj is not sock:
                    continue
                while True:
                    try:
                        datagram, _addr = sock.recvfrom(65535)
                    except BlockingIOError:
                        break
                    except OSError:
                        break
                    if not datagram:
                        continue
                    total_packets += 1
                    console.log(f"[TOP] received datagram len={len(datagram)} total={total_packets}")
                    try:
                        record = build_record(datagram, now)
                    except Exception as exc:
                        console.log(f"[TOP] decode failed: {exc}")
                        continue
                    if not matches_filters(record, module_id_filter, module_type_filter, host_id_filter):
                        filtered_packets += 1
                        console.log(f"[TOP] filtered module_id={record.header.module_id} host_id={record.header.host_id}")
                        continue
                    modules[record.key] = record
            prune_stale(modules, now, idle_sec)
            live.update(render_dashboard(modules, now))


if __name__ == "__main__":
    main()
