#!/usr/bin/env python3

import atexit
import selectors
import signal
import socket
import sys
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import click
from rich import box
from rich.align import Align
from rich.columns import Columns
from rich.console import Console, Group
from rich.live import Live
from rich.panel import Panel
from rich.table import Table
from rich.text import Text

from wfbxlib.stats import core as stats_core
from wfbxlib.stats import mx as stats_mx

console = Console()

@dataclass
class ModuleRecord:
    key: str
    kind: str
    header: stats_core.Header
    summary: Optional[stats_core.Summary]
    text_preview: Optional[str]
    tx_entries: List[stats_mx.TxSummary]
    if_entries: List[stats_mx.IfDetail]
    global_debug: Optional[stats_mx.GlobalDebug]
    last_update: float


def create_mcast_socket(group_ip: str, port: int) -> socket.socket:
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        sock.bind(("", port))
    except OSError:
        sock.bind((group_ip, port))
    group_bin = socket.inet_aton(group_ip)
    iface_bins: List[bytes] = [socket.inet_aton("0.0.0.0")]
    try:
        iface_bins.append(socket.inet_aton("127.0.0.1"))
    except OSError:
        pass
    for iface_bin in iface_bins:
        mreq = group_bin + iface_bin
        try:
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
        except OSError:
            continue
    sock.setblocking(False)
    return sock


def parse_sections(header: stats_core.Header, sections: List[Tuple[int, bytes]]):
    summary: Optional[stats_core.Summary] = None
    text_preview: Optional[str] = None
    tx_entries: List[stats_mx.TxSummary] = []
    if_entries: List[stats_mx.IfDetail] = []
    global_debug: Optional[stats_mx.GlobalDebug] = None

    for section_type, payload in sections:
        if section_type == stats_core.SectionType.SUMMARY:
            try:
                summary = stats_core.Summary.unpack(payload)
            except ValueError:
                continue
        elif section_type == stats_core.SectionType.TEXT_PREVIEW:
            text_preview = payload.rstrip(b"\0").decode("utf-8", "ignore")
        elif header.module_type == stats_core.ModuleType.MX:
            try:
                mx_type = stats_mx.SectionType(section_type)
            except ValueError:
                continue
            if mx_type == stats_mx.SectionType.TX_SUMMARY:
                try:
                    tx_entries = stats_mx.unpack_tx_summary_section(payload)
                except ValueError:
                    tx_entries = []
            elif mx_type == stats_mx.SectionType.IF_DETAIL:
                try:
                    if_entries = stats_mx.unpack_if_detail_section(payload)
                except ValueError:
                    if_entries = []
            elif mx_type == stats_mx.SectionType.GLOBAL_DEBUG:
                try:
                    global_debug = stats_mx.GlobalDebug.unpack(payload)
                except ValueError:
                    global_debug = None

    return summary, text_preview, tx_entries, if_entries, global_debug


def detect_kind(header: stats_core.Header) -> str:
    module_id = (header.module_id or "").lower()
    if header.module_type == stats_core.ModuleType.MX:
        return "mx"
    if module_id.startswith("xtx"):
        return "xtx"
    if module_id.startswith("xrx"):
        return "xrx"
    if module_id.startswith("rxx"):
        return "rxx"
    if header.module_type == stats_core.ModuleType.TX:
        return "tx"
    if header.module_type == stats_core.ModuleType.RX:
        return "rx"
    return "unknown"


def build_record(datagram: bytes, now: float) -> ModuleRecord:
    header, sections = stats_core.decode_packet(datagram, verify_crc=False)
    summary, text_preview, tx_entries, if_entries, global_debug = parse_sections(header, sections)
    host_id = header.host_id or "unknown"
    module_id = header.module_id or "unknown"
    key = f"{module_id}@{host_id}"
    kind = detect_kind(header)
    return ModuleRecord(
        key=key,
        kind=kind,
        header=header,
        summary=summary,
        text_preview=text_preview,
        tx_entries=tx_entries,
        if_entries=if_entries,
        global_debug=global_debug,
        last_update=now,
    )


def matches_filters(record: ModuleRecord,
                    module_id_filter: str,
                    module_type_filter: str,
                    host_id_filter: str) -> bool:
    module_id = record.header.module_id or ""
    host_id = record.header.host_id or ""
    if module_id_filter and module_id_filter.lower() not in module_id.lower():
        return False
    if host_id_filter and host_id_filter.lower() not in host_id.lower():
        return False
    if module_type_filter:
        mt = record.kind.lower()
        mt_name = record.header.module_type.name.lower()
        filt = module_type_filter.lower()
        if filt not in mt and filt not in mt_name:
            return False
    return True


def prune_stale(modules: Dict[str, ModuleRecord], now: float, idle_sec: float) -> None:
    stale = [key for key, rec in modules.items() if now - rec.last_update > idle_sec]
    for key in stale:
        modules.pop(key, None)


def render_summary_table(record: ModuleRecord) -> Table:
    table = Table.grid(expand=True)
    table.add_column(justify="left", style="cyan")
    table.add_column(justify="right", style="bold")
    table.add_row("Host", record.header.host_id or "-")
    table.add_row("Tick", str(record.header.tick_id))
    table.add_row("Flags", f"0x{record.header.flags:04X}")
    if record.summary is not None:
        summary = record.summary
        table.add_row("Window ms", str(summary.dt_ms))
        table.add_row("Packets", str(summary.packets_total))
        table.add_row("Bytes", str(summary.bytes_total))
        table.add_row("Interfaces", str(summary.iface_count))
        table.add_row("TX count", str(summary.tx_count))
    else:
        table.add_row("Summary", "n/a")
    return table


def render_mx(record: ModuleRecord) -> Group:
    blocks: List = []
    summary = record.summary
    if summary is not None:
        summary_line = Text(
            f"pkts={summary.packets_total} ctrl_epoch={summary.ctrl_epoch_sent} "
            f"tx={summary.tx_count} ifaces={summary.iface_count}",
            style="cyan",
        )
    else:
        summary_line = Text("summary unavailable", style="dim")
    blocks.append(summary_line)

    if record.tx_entries:
        dt_ms = summary.dt_ms if summary and summary.dt_ms > 0 else 1000
        blocks.append(Text("·" * 40, style="magenta"))
        for entry in record.tx_entries:
            pkts_per_sec = entry.packets * 1000.0 / dt_ms if dt_ms > 0 else float(entry.packets)
            rssi = entry.rssi_q8 / 256.0
            quality = entry.quality_permille / 10.0
            line = (
                f"tx_id {entry.tx_id}: pkts/s {pkts_per_sec:.1f} | "
                f"lost {entry.lost} | rate {entry.rate_kbps} kbps | "
                f"rssi {rssi:.1f} dBm | qlt {quality:.1f}%"
            )
            blocks.append(Text(line, style="magenta"))

            # Antenna-level detail for this TX
            chain_rows: List[List[object]] = []
            for if_entry in record.if_entries:
                if if_entry.tx_id != entry.tx_id:
                    continue
                iface_id = if_entry.iface_id
                for chain in if_entry.chains:
                    chain_quality = chain.quality_permille / 10.0
                    chain_rssi = chain.rssi_avg_q8 / 256.0
                    chain_rows.append(
                        [
                            f"{iface_id}",
                            f"{chain.ant_id}",
                            f"{chain.packets}",
                            f"{chain.lost}",
                            f"{chain_rssi:.1f}",
                            render_signal_bar(chain_rssi),
                            f"{chain_quality:.1f}"
                        ]
                    )

            if chain_rows:
                chain_table = Table(
                    show_header=True,
                    header_style="cyan",
                    expand=True,
                    box=None,
                    padding=(0, 1),
                )
                chain_table.add_column("if", justify="right")
                chain_table.add_column("ant", justify="right")
                chain_table.add_column("pkts", justify="right")
                chain_table.add_column("lost", justify="right")
                chain_table.add_column("rssi", justify="right")
                chain_table.add_column("signal", justify="center")
                chain_table.add_column("qlt %", justify="right")
                for row in chain_rows:
                    chain_table.add_row(*row)
                blocks.append(chain_table)

    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))
    return Group(*blocks)


def render_generic(record: ModuleRecord, label: str) -> Group:
    blocks: List = [render_summary_table(record)]
    if record.text_preview:
        blocks.append(Panel(Text(record.text_preview, style="dim"), title="preview", border_style="cyan"))
    return Group(*blocks)

#[∣❘❙❚¦]
def render_signal_bar(rssi: float) -> Text:
    thresholds = [
        -80.0, -75.0, -74.0, -73.0, -72.0,
        -71.0, -70.0, -71.0, -70.0, -69.0,
        -68.0, -66.0, -64.0, -62.0, -60.0,
        -58.0, -56.0, -54.0, -52.0, -50.0,
        -45.0, -35.0, -25.0, -5.0, 16.0,
    ]
    active = sum(1 for th in thresholds if rssi >= th)
    bar = Text("[")
    for idx, _ in enumerate(thresholds):
        style = "red" if idx < 2 else "yellow" if idx < 6 else "green"
        if idx < active:
            bar.append("¦", style=style)
        else:
            bar.append("·", style="dim")
    bar.append("]")
    return bar


def render_module(record: ModuleRecord, now: float) -> Panel:
    age = now - record.last_update
    if record.kind == "mx":
        host = record.header.host_id or "-"
        module = record.header.module_id or "unknown"
        title = f"{host}.{module}"
    else:
        title = f"{record.header.module_id or 'unknown'} [{record.kind}]"
    subtitle = f"age {age:0.1f}s"
    if record.kind == "mx":
        body = render_mx(record)
    elif record.kind in {"rx", "xrx", "rxx"}:
        body = render_generic(record, "rx")
    elif record.kind in {"tx", "xtx"}:
        body = render_generic(record, "tx")
    else:
        body = render_generic(record, "stat")
    return Panel(body, title=title, subtitle=subtitle, border_style="green")


def render_dashboard(modules: Dict[str, ModuleRecord], now: float) -> Panel:
    if not modules:
        return Panel(Align.center(Text("Awaiting telemetry...", style="dim"), vertical="middle"), border_style="blue")
    ordered = [modules[key] for key in sorted(modules.keys())]
    panels = [render_module(rec, now) for rec in ordered]
    return Panel(Columns(panels, expand=True), border_style="blue", title="wfbx_top")


@click.command()
@click.option("--ip", "mcast_ip", default="239.255.0.1", show_default=True, help="Multicast group IP")
@click.option("--port", default=9100, type=int, show_default=True, help="Multicast group port")
@click.option("--idle-ms", default=4000, type=int, show_default=True, help="Evict module if idle longer than this (ms)")
@click.option("--module-id", "module_id_filter", default="", help="Substring filter for module_id")
@click.option("--module-type", "module_type_filter", default="", help="Substring filter for module_type")
@click.option("--host-id", "host_id_filter", default="", help="Substring filter for host_id")
def main(mcast_ip: str,
         port: int,
         idle_ms: int,
         module_id_filter: str,
         module_type_filter: str,
         host_id_filter: str) -> None:
    sock: Optional[socket.socket] = None

    def cleanup() -> None:
        if sock is not None:
            try:
                sock.close()
            except Exception:
                pass

    def handle_signal(_sig, _frame) -> None:
        cleanup()
        sys.exit(0)

    atexit.register(cleanup)
    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    modules: Dict[str, ModuleRecord] = {}
    idle_sec = idle_ms / 1000.0 if idle_ms > 0 else float("inf")

    sock = create_mcast_socket(mcast_ip, port)
    selector = selectors.DefaultSelector()
    selector.register(sock, selectors.EVENT_READ)

    total_packets = 0
    filtered_packets = 0

    with Live(render_dashboard(modules, time.time()), refresh_per_second=5, console=console) as live:
        while True:
            events = selector.select(timeout=0.5)
            now = time.time()
            for key, _mask in events:
                if key.fileobj is not sock:
                    continue
                while True:
                    try:
                        datagram, _addr = sock.recvfrom(65535)
                    except BlockingIOError:
                        break
                    except OSError:
                        break
                    if not datagram:
                        continue
                    total_packets += 1
                    console.log(f"[TOP] received datagram len={len(datagram)} total={total_packets}")
                    try:
                        record = build_record(datagram, now)
                    except Exception as exc:
                        console.log(f"[TOP] decode failed: {exc}")
                        continue
                    if not matches_filters(record, module_id_filter, module_type_filter, host_id_filter):
                        filtered_packets += 1
                        console.log(f"[TOP] filtered module_id={record.header.module_id} host_id={record.header.host_id}")
                        continue
                    modules[record.key] = record
            prune_stale(modules, now, idle_sec)
            live.update(render_dashboard(modules, now))


if __name__ == "__main__":
    main()
